This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-21T04:02:00.173Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
.eslintrc.js
.github/workflows/build.yml
.gitignore
.npmrc
electron-builder.yml
electron/main.cjs
electron/preload.cjs
electron/whisperModule.cjs
electron/youtubeDownloader.cjs
index.html
package.json
postcss.config.cjs
src/App.jsx
src/components/ConsoleOutput.jsx
src/components/FileInput.jsx
src/components/Header.jsx
src/components/OutputSection.jsx
src/components/TranscriptionSettings.jsx
src/components/YoutubeInput.jsx
src/hooks/useTranscription.js
src/hooks/useYoutubeDownload.js
src/main.jsx
src/store.js
src/styles/globals.css
tailwind.config.cjs
vite.config.js

================================================================
Repository Files
================================================================

================
File: .eslintrc.js
================
module.exports = {
  root: true,
  env: { browser: true, es2020: true },
  extends: [
    "eslint:recommended",
    "plugin:@typescript-eslint/recommended",
    "plugin:@typescript-eslint/recommended-requiring-type-checking",
    "plugin:react-hooks/recommended",
  ],
  parser: "@typescript-eslint/parser",
  parserOptions: {
    ecmaVersion: "latest",
    sourceType: "module",
    project: true,
    tsconfigRootDir: __dirname,
  },
  plugins: ["react-refresh"],
  rules: {
    "react-refresh/only-export-components": [
      "warn",
      { allowConstantExport: true },
    ],
    "@typescript-eslint/no-unused-vars": ["error", { argsIgnorePattern: "^_" }],
  },
};

================
File: .github/workflows/build.yml
================
name: Build and Release

on:
  push:
    tags:
      - 'v*'

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        os: [windows-latest, ubuntu-latest, macos-latest]

    steps:
      - uses: actions/checkout@v2
      
      - name: Setup Node.js
        uses: actions/setup-node@v2
        with:
          node-version: '18'
          
      - name: Install dependencies
        run: npm ci
        
      - name: Download models
        run: node scripts/download-models.js
        
      - name: Build
        run: npm run build
        
      - name: Upload artifacts
        uses: actions/upload-artifact@v2
        with:
          name: dist-${{ matrix.os }}
          path: dist

  release:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v2
      
      - name: Download artifacts
        uses: actions/download-artifact@v2
        
      - name: Create Release
        uses: softprops/action-gh-release@v1
        with:
          files: dist-*/*
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

================
File: .gitignore
================
node_modules
package-lock.json
dist-electron
dist
/resources

================
File: .npmrc
================
runtime = electron
target = 28.3.3
target_arch = x64
disturl = https://electronjs.org/headers

================
File: electron-builder.yml
================
appId: com.googlyblox.transcriber
productName: Transcriber App
directories:
  buildResources: build
  output: dist_electron
files:
  - dist/**/*
  - dist-electron/**/*
  - resources/**/*
  - "!**/node_modules/*/{CHANGELOG.md,README.md,README,readme.md,readme}"
  - "!**/node_modules/*/{test,__tests__,tests,powered-test,example,examples}"
extraResources:
  - from: resources
    to: resources
    filter:
      - "**/*"
win:
  target: nsis
  icon: build/icon.ico
mac:
  target: dmg
  icon: build/icon.icns
linux:
  target: AppImage
  icon: build/icon.png
nsis:
  oneClick: false
  allowToChangeInstallationDirectory: true

================
File: electron/main.cjs
================
const { app, BrowserWindow, ipcMain } = require("electron")
const path = require("path")
const { registerWhisperHandlers } = require("./whisperModule.cjs")
const { registerYoutubeHandlers } = require("./youtubeDownloader.cjs")

const isDev = process.env.NODE_ENV === "development"
let mainWindow = null

function createWindow() {
  mainWindow = new BrowserWindow({
    width: 1200,
    height: 800,
    webPreferences: {
      nodeIntegration: false,
      contextIsolation: true,
      preload: path.join(__dirname, "../preload/preload.cjs"),
      sandbox: false
    }
  })

  if (isDev) {
    mainWindow.loadURL("http://localhost:5173")
    mainWindow.webContents.openDevTools()
  } else {
    mainWindow.loadFile(path.join(__dirname, "../dist/index.html"))
  }

  mainWindow.webContents.on("did-fail-load", (_, errorCode, errorDescription) => {
    console.error("Failed to load:", errorCode, errorDescription)
  })
}

app.whenReady().then(() => {
  createWindow()
  registerWhisperHandlers(ipcMain)
  registerYoutubeHandlers(ipcMain)

  app.on("activate", () => {
    if (BrowserWindow.getAllWindows().length === 0) {
      createWindow()
    }
  })
})

app.on("window-all-closed", () => {
  if (process.platform !== "darwin") {
    app.quit()
  }
})

================
File: electron/preload.cjs
================
const { contextBridge, ipcRenderer } = require('electron');

const listeners = new Set();

contextBridge.exposeInMainWorld('api', {
  transcribe: (filePath, options) => 
    ipcRenderer.invoke('transcribe', filePath, options),
  downloadYoutube: (url) => 
    ipcRenderer.invoke('download-youtube', url),
  selectDirectory: () => 
    ipcRenderer.invoke('select-directory'),
  onProgress: (callback) => {
    const listener = (_event, progress) => callback(progress);
    listeners.add(listener);
    ipcRenderer.on('progress', listener);
    
    return () => {
      listeners.delete(listener);
      ipcRenderer.removeListener('progress', listener);
    };
  }
});

if (typeof window !== 'undefined') {
  window.addEventListener('unload', () => {
    listeners.forEach(listener => {
      ipcRenderer.removeListener('progress', listener);
    });
    listeners.clear();
  });
}

module.exports = {};

================
File: electron/whisperModule.cjs
================
const { pipeline } = require("@xenova/transformers")
const fs = require("fs")
const path = require("path")
const { app } = require("electron")
const ffmpeg = require("fluent-ffmpeg")
const ffmpegInstaller = require("@ffmpeg-installer/ffmpeg")

// Configure ffmpeg path
ffmpeg.setFfmpegPath(ffmpegInstaller.path)

function bufferToFloat32Array(buffer) {
  const pcm16 = new Int16Array(buffer.buffer, buffer.byteOffset, buffer.length / 2)
  const float32 = new Float32Array(pcm16.length)
  
  for (let i = 0; i < pcm16.length; i++) {
    float32[i] = pcm16[i] / 32768.0
  }
  
  return float32
}

async function convertToWav(inputPath) {
  const tmpDir = path.join(app.getPath('temp'), 'transcriber-temp')
  await fs.promises.mkdir(tmpDir, { recursive: true })
  
  const outputPath = path.join(tmpDir, `${Date.now()}_converted.wav`)
  
  return new Promise((resolve, reject) => {
    ffmpeg(inputPath)
      .toFormat('wav')
      .outputOptions([
        '-acodec pcm_s16le',
        '-ac 1',
        '-ar 16000'
      ])
      .on('error', reject)
      .on('end', () => resolve(outputPath))
      .save(outputPath)
  })
}

export function registerWhisperHandlers(ipcMain) {
  ipcMain.handle("transcribe", async (event, filePath, options) => {
    try {
      event.sender.send("progress", "Initializing transcriber...")

      const transcriber = await pipeline(
        "automatic-speech-recognition",
        `Xenova/whisper-${options.modelSize}`,
        {
          progress_callback: (progress) => {
            if (progress.status === 'progress') {
              event.sender.send("progress", `Loading model: ${Math.round(progress.value * 100)}%`)
            }
          }
        }
      )

      event.sender.send("progress", "Converting audio file...")
      const wavPath = await convertToWav(filePath)
      
      event.sender.send("progress", "Loading audio file...")
      const audioData = await fs.promises.readFile(wavPath)
      const float32Audio = bufferToFloat32Array(audioData)
      
      // Clean up the temporary WAV file
      await fs.promises.unlink(wavPath)
      
      event.sender.send("progress", "Starting transcription...")
      const result = await transcriber(float32Audio, {
        language: options.language !== "auto" ? options.language : undefined,
        task: options.task,
        chunk_length_s: 30,
        stride_length_s: 5,
        return_timestamps: true,
        callback_function: (progress) => {
          event.sender.send("progress", `Transcription progress: ${Math.round(progress * 100)}%`)
        }
      })

      if (!result || !result.text) {
        throw new Error("No transcription result generated")
      }

      const outputDir = path.dirname(filePath)
      const baseName = path.basename(filePath, path.extname(filePath))

      event.sender.send("progress", "Writing output files...")
      await fs.promises.writeFile(
        path.join(outputDir, `${baseName}.txt`),
        result.text,
        "utf-8"
      )

      if (options.addSubtitles && result.chunks) {
        const srtContent = result.chunks
          .map((chunk, index) => {
            const startTime = formatSrtTime(chunk.timestamp[0] * 1000)
            const endTime = formatSrtTime(chunk.timestamp[1] * 1000)
            return `${index + 1}\n${startTime} --> ${endTime}\n${chunk.text}\n\n`
          })
          .join("")

        await fs.promises.writeFile(
          path.join(outputDir, `${baseName}.srt`),
          srtContent,
          "utf-8"
        )
      }

      event.sender.send("progress", "Transcription complete!")
      return result.text
    } catch (error) {
      console.error("Transcription error:", error)
      event.sender.send("progress", `Error: ${error.message}`)
      throw error
    }
  })
}

function formatSrtTime(ms) {
  const hours = Math.floor(ms / 3600000)
  const minutes = Math.floor((ms % 3600000) / 60000)
  const seconds = Math.floor((ms % 60000) / 1000)
  const milliseconds = Math.floor(ms % 1000)

  return `${String(hours).padStart(2, "0")}:${String(minutes).padStart(2, "0")}:${String(seconds).padStart(2, "0")},${String(milliseconds).padStart(3, "0")}`
}

module.exports = { registerWhisperHandlers }

================
File: electron/youtubeDownloader.cjs
================
const ytdl = require("ytdl-core")
const path = require("path")
const fs = require("fs")
const { app, dialog } = require("electron")

export function registerYoutubeHandlers(ipcMain) {
  ipcMain.handle("download-youtube", async (_event, url) => {
    try {
      const info = await ytdl.getInfo(url)
      const videoId = info.videoDetails.videoId
      const tempDir = path.join(app.getPath("temp"), "transcriber-downloads")
      
      if (!fs.existsSync(tempDir)) {
        fs.mkdirSync(tempDir, { recursive: true })
      }

      const outputPath = path.join(tempDir, `${videoId}.mp4`)
      const writeStream = fs.createWriteStream(outputPath)

      return new Promise((resolve, reject) => {
        ytdl(url, {
          quality: "highestaudio",
          filter: "audioonly"
        })
          .on("progress", (_, downloaded, total) => {
            const percent = (downloaded / total) * 100
            _event.sender.send("progress", `Downloading: ${percent.toFixed(2)}%`)
          })
          .pipe(writeStream)
          .on("finish", () => resolve(outputPath))
          .on("error", reject)
      })
    } catch (error) {
      console.error("Download error:", error)
      throw error
    }
  })

  ipcMain.handle("select-directory", async () => {
    const result = await dialog.showOpenDialog({
      properties: ["openDirectory"]
    })

    if (!result.canceled) {
      return result.filePaths[0]
    }
    return null
  })
}

module.exports = { registerYoutubeHandlers }

================
File: index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Transcriber App</title>
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.jsx"></script>
  </body>
</html>

================
File: package.json
================
{
  "name": "transcriber-app",
  "version": "1.0.0",
  "author": "GooglyBlox",
  "description": "Audio/Video Transcription Application",
  "main": "dist-electron/main/main.cjs",
  "type": "module",
  "scripts": {
    "dev": "cross-env NODE_ENV=development vite",
    "build": "vite build && electron-builder",
    "preview": "vite preview",
    "clean": "rimraf dist dist-electron .vite/deps node_modules/.vite"
  },
  "dependencies": {
    "@ffmpeg-installer/ffmpeg": "^1.1.0",
    "@xenova/transformers": "^2.14.0",
    "electron-store": "^8.2.0",
    "fluent-ffmpeg": "^2.1.3",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "sharp": "^0.33.5",
    "tailwindcss": "^3.4.1",
    "winston": "^3.11.0",
    "ytdl-core": "^4.11.5",
    "zustand": "^4.5.0"
  },
  "devDependencies": {
    "@vitejs/plugin-react": "^4.2.1",
    "autoprefixer": "^10.4.17",
    "concurrently": "^9.1.2",
    "cross-env": "^7.0.3",
    "electron": "^28.2.1",
    "electron-builder": "^24.9.1",
    "fs-extra": "^11.3.0",
    "postcss": "^8.4.35",
    "rimraf": "^5.0.10",
    "vite": "^5.0.12",
    "vite-plugin-electron": "^0.28.0",
    "vite-plugin-electron-renderer": "^0.14.5"
  }
}

================
File: postcss.config.cjs
================
module.exports = {
  plugins: {
    tailwindcss: {},
    autoprefixer: {},
  },
}

================
File: src/App.jsx
================
import React from "react";
import { Header } from "./components/Header";
import { FileInput } from "./components/FileInput";
import { YoutubeInput } from "./components/YoutubeInput";
import { TranscriptionSettings } from "./components/TranscriptionSettings";
import { OutputSection } from "./components/OutputSection";
import { ConsoleOutput } from "./components/ConsoleOutput";
import { useTranscription } from "./hooks/useTranscription";
import { useYoutubeDownload } from "./hooks/useYoutubeDownload";

const App = () => {
  const { transcribe, progress } = useTranscription();
  const { downloadVideo } = useYoutubeDownload();

  const handleFiles = async (files) => {
    for (const file of files) {
      if (file.path) {
        await transcribe(file.path);
      } else {
        console.error("File path not available:", file);
      }
    }
  };

  const handleYoutubeUrl = async (url) => {
    const filePath = await downloadVideo(url);
    if (filePath) {
      await transcribe(filePath);
    }
  };

  return (
    <div className="min-h-screen bg-gray-50 dark:bg-gray-900">
      <Header />
      <main className="container mx-auto px-4 py-8">
        <div className="grid grid-cols-1 lg:grid-cols-2 gap-8">
          <FileInput onFilesSelected={handleFiles} />
          <YoutubeInput onUrlSubmit={handleYoutubeUrl} />
        </div>
        <TranscriptionSettings />
        <OutputSection />
        <ConsoleOutput text={progress} />
      </main>
    </div>
  );
};

export default App;

================
File: src/components/ConsoleOutput.jsx
================
import React, { useEffect, useRef } from "react"

export const ConsoleOutput = ({ text }) => {
  const outputRef = useRef(null)

  useEffect(() => {
    if (outputRef.current) {
      outputRef.current.scrollTop = outputRef.current.scrollHeight
    }
  }, [text])

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg p-6 mt-8">
      <h2 className="text-lg font-medium mb-4">Console Output</h2>
      <pre
        ref={outputRef}
        className="bg-gray-50 dark:bg-gray-900 p-4 rounded-lg h-64 overflow-auto font-mono text-sm text-gray-800 dark:text-gray-200"
      >
        {text || "No output yet..."}
      </pre>
    </div>
  )
}

================
File: src/components/FileInput.jsx
================
import React, { useCallback } from "react";

export const FileInput = ({ onFilesSelected }) => {
  const handleFiles = useCallback(
    async (files) => {
      try {
        const fileArray = Array.from(files);
        onFilesSelected(fileArray);
      } catch (error) {
        console.error("Error handling files:", error);
      }
    },
    [onFilesSelected]
  );

  const handleDrop = useCallback(
    (e) => {
      e.preventDefault();
      if (e.dataTransfer.files) {
        handleFiles(e.dataTransfer.files);
      }
    },
    [handleFiles]
  );

  const handleDragOver = useCallback((e) => {
    e.preventDefault();
  }, []);

  const handleFileInput = useCallback(
    (e) => {
      if (e.target.files) {
        handleFiles(e.target.files);
      }
    },
    [handleFiles]
  );

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg p-6">
      <h2 className="text-lg font-medium mb-4">Local Files</h2>
      <div
        className="border-2 border-dashed border-gray-300 dark:border-gray-600 rounded-lg p-8 text-center"
        onDrop={handleDrop}
        onDragOver={handleDragOver}
      >
        <input
          type="file"
          onChange={handleFileInput}
          className="hidden"
          id="fileInput"
          multiple
          accept="audio/*,video/*"
        />
        <label
          htmlFor="fileInput"
          className="cursor-pointer text-gray-600 dark:text-gray-400"
        >
          <div className="flex flex-col items-center">
            <svg
              className="w-8 h-8 mb-2"
              fill="none"
              stroke="currentColor"
              viewBox="0 0 24 24"
            >
              <path
                strokeLinecap="round"
                strokeLinejoin="round"
                strokeWidth={2}
                d="M7 16a4 4 0 01-.88-7.903A5 5 0 1115.9 6L16 6a5 5 0 011 9.9M15 13l-3-3m0 0l-3 3m3-3v12"
              />
            </svg>
            <span>Drop files here or click to select</span>
          </div>
        </label>
      </div>
    </div>
  );
};

================
File: src/components/Header.jsx
================
import React from "react"

export const Header = () => (
  <header className="bg-white dark:bg-gray-800 border-b border-gray-200 dark:border-gray-700">
    <div className="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-4">
      <h1 className="text-2xl font-semibold text-gray-900 dark:text-white">
        Audio/Video Transcription
      </h1>
    </div>
  </header>
)

================
File: src/components/OutputSection.jsx
================
import React from "react"
import { useStore } from "../store"

export const OutputSection = () => {
  const { outputDirectory, setOutputDirectory } = useStore()

  const handleSelectDirectory = async () => {
    const directory = await window.api.selectDirectory()
    if (directory) {
      setOutputDirectory(directory)
    }
  }

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg p-6 mt-8">
      <h2 className="text-lg font-medium mb-4">Output Settings</h2>
      <div className="space-y-4">
        <button onClick={handleSelectDirectory} className="btn-primary w-full">
          Select Output Directory
        </button>
        {outputDirectory && (
          <div className="text-sm text-gray-600 dark:text-gray-400 truncate">
            Output Directory: {outputDirectory}
          </div>
        )}
      </div>
    </div>
  )
}

================
File: src/components/TranscriptionSettings.jsx
================
import React from "react";
import { useStore } from "../store";

export const TranscriptionSettings = () => {
  const { settings, updateSettings } = useStore();

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg p-6 mt-8">
      <h2 className="text-lg font-medium mb-4">Transcription Settings</h2>
      <div className="grid grid-cols-1 md:grid-cols-2 gap-6">
        <div>
          <label className="block text-sm font-medium mb-1">Model Size</label>
          <select
            value={settings.modelSize}
            onChange={(e) => updateSettings({ modelSize: e.target.value })}
            className="input-field"
          >
            <option value="base">Base</option>
            <option value="small">Small</option>
            <option value="medium">Medium</option>
            <option value="large-v3-turbo">Large</option>
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium mb-1">Language</label>
          <select
            value={settings.language}
            onChange={(e) => updateSettings({ language: e.target.value })}
            className="input-field"
          >
            <option value="auto">Auto-detect</option>
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium mb-1">Task</label>
          <select
            value={settings.task}
            onChange={(e) => updateSettings({ task: e.target.value })}
            className="input-field"
          >
            <option value="transcribe">Transcribe</option>
            <option value="translate">Translate</option>
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium mb-1">Device</label>
          <select
            value={settings.device}
            onChange={(e) => updateSettings({ device: e.target.value })}
            className="input-field"
          >
            <option value="cpu">CPU</option>
            <option value="cuda">GPU (CUDA)</option>
          </select>
        </div>
      </div>
      <div className="mt-4">
        <label className="flex items-center space-x-2">
          <input
            type="checkbox"
            checked={settings.addSubtitles}
            onChange={(e) => updateSettings({ addSubtitles: e.target.checked })}
            className="rounded border-gray-300 text-blue-600 focus:ring-blue-500"
          />
          <span>Generate Subtitles</span>
        </label>
      </div>
    </div>
  );
};

================
File: src/components/YoutubeInput.jsx
================
import React, { useState, useCallback } from "react"

export const YoutubeInput = ({ onUrlSubmit }) => {
  const [url, setUrl] = useState("")
  const [urls, setUrls] = useState([])

  const handleSubmit = useCallback(
    (e) => {
      e.preventDefault()
      if (url && !urls.includes(url)) {
        setUrls([...urls, url])
        setUrl("")
      }
    },
    [url, urls]
  )

  const handleProcess = useCallback(() => {
    urls.forEach((url) => onUrlSubmit(url))
    setUrls([])
  }, [urls, onUrlSubmit])

  const removeUrl = useCallback((indexToRemove) => {
    setUrls((prev) => prev.filter((_, index) => index !== indexToRemove))
  }, [])

  return (
    <div className="bg-white dark:bg-gray-800 rounded-lg p-6">
      <h2 className="text-lg font-medium mb-4">YouTube Download</h2>
      <form onSubmit={handleSubmit} className="space-y-4">
        <input
          type="text"
          value={url}
          onChange={(e) => setUrl(e.target.value)}
          placeholder="Enter YouTube URL"
          className="input-field"
        />
        <div className="space-y-2">
          {urls.map((url, index) => (
            <div
              key={index}
              className="flex items-center justify-between bg-gray-50 dark:bg-gray-700 p-2 rounded"
            >
              <span className="truncate flex-1">{url}</span>
              <button
                onClick={() => removeUrl(index)}
                className="ml-2 text-red-600 hover:text-red-800 dark:text-red-400"
              >
                <svg
                  className="w-5 h-5"
                  fill="none"
                  stroke="currentColor"
                  viewBox="0 0 24 24"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>
          ))}
        </div>
        {urls.length > 0 && (
          <button
            type="button"
            onClick={handleProcess}
            className="btn-primary w-full"
          >
            Process URLs
          </button>
        )}
      </form>
    </div>
  )
}

================
File: src/hooks/useTranscription.js
================
import { useState, useEffect } from "react"
import { useStore } from "../store"

export const useTranscription = () => {
  const [progress, setProgress] = useState("")
  const { settings } = useStore()

  useEffect(() => {
    if (!window.api?.onProgress) {
      console.warn('API not initialized yet')
      return
    }

    const cleanup = window.api.onProgress((progressText) => {
      setProgress((prev) => `${prev}\n${progressText}`)
    })

    return () => {
      if (typeof cleanup === 'function') {
        cleanup()
      }
    }
  }, [])

  const transcribe = async (filePath) => {
    if (!window.api?.transcribe) {
      console.error('Transcribe API not available')
      return
    }

    try {
      await window.api.transcribe(filePath, settings)
    } catch (error) {
      setProgress((prev) => `${prev}\nError: ${error.message}`)
    }
  }

  return { transcribe, progress }
}

================
File: src/hooks/useYoutubeDownload.js
================
import { useState } from "react"

export const useYoutubeDownload = () => {
  const [downloading, setDownloading] = useState(false)

  const downloadVideo = async (url) => {
    try {
      setDownloading(true)
      const filePath = await window.api.downloadYoutube(url)
      return filePath
    } catch (error) {
      console.error("Download failed:", error)
      return null
    } finally {
      setDownloading(false)
    }
  }

  return { downloadVideo, downloading }
}

================
File: src/main.jsx
================
import React from "react"
import ReactDOM from "react-dom/client"
import App from "./App"
import "./styles/globals.css"

ReactDOM.createRoot(document.getElementById("root")).render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
)

================
File: src/store.js
================
import { create } from "zustand"
import { persist } from "zustand/middleware"

export const useStore = create(
  persist(
    (set) => ({
      settings: {
        modelSize: "base",
        language: "auto",
        task: "transcribe",
        device: "cpu",
        addSubtitles: false,
      },
      outputDirectory: null,
      updateSettings: (newSettings) =>
        set((state) => ({
          settings: { ...state.settings, ...newSettings },
        })),
      setOutputDirectory: (directory) =>
        set({ outputDirectory: directory }),
    }),
    {
      name: "transcription-settings",
    }
  )
)

================
File: src/styles/globals.css
================
@tailwind base;
@tailwind components;
@tailwind utilities;

@layer base {
  body {
    @apply bg-gray-50 dark:bg-gray-900 text-gray-900 dark:text-white;
  }
}

@layer components {
  .btn-primary {
    @apply px-4 py-2 bg-blue-600 text-white rounded-lg hover:bg-blue-700 
           focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2 
           transition-colors disabled:opacity-50;
  }

  .input-field {
    @apply w-full px-3 py-2 bg-white dark:bg-gray-800 border border-gray-300 
           dark:border-gray-700 rounded-lg focus:outline-none focus:ring-2 
           focus:ring-blue-500 dark:focus:ring-blue-400;
  }
}

================
File: tailwind.config.cjs
================
module.exports = {
  content: ["./src/**/*.{js,jsx}"],
  darkMode: "class",
  theme: {
    extend: {
      colors: {
        primary: {
          DEFAULT: "#3B82F6",
          dark: "#2563EB",
        },
      },
    },
  },
  plugins: [],
}

================
File: vite.config.js
================
import { defineConfig } from "vite"
import electron from "vite-plugin-electron"
import renderer from "vite-plugin-electron-renderer"
import react from "@vitejs/plugin-react"
import path from "path"
import { fileURLToPath } from "url"
import fs from 'fs-extra'

const __filename = fileURLToPath(import.meta.url)
const __dirname = path.dirname(__filename)

const electronFiles = [
  'preload.cjs',
  'main.cjs',
  'whisperModule.cjs',
  'youtubeDownloader.cjs'
]

electronFiles.forEach(file => {
  fs.copySync(
    path.join(__dirname, 'electron', file),
    path.join(__dirname, 'dist-electron/main', file)
  )
})

export default defineConfig({
  plugins: [
    react(),
    electron([
      {
        onstart(options) {
          options.startup()
        }
      }
    ]),
    renderer()
  ],
  build: {
    outDir: "dist",
    emptyOutDir: true,
    rollupOptions: {
      input: {
        index: path.resolve(__dirname, 'index.html')
      }
    }
  },
  resolve: {
    alias: {
      '@': path.resolve(__dirname, './src'),
    }
  }
})
